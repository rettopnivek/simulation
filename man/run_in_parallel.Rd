% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R04-convenience_functions.R
\name{run_in_parallel}
\alias{run_in_parallel}
\title{Run a Function in Parallel Across Multiple Cores}
\usage{
run_in_parallel(
  func_for_iter,
  to_export = "",
  packages_to_load = NULL,
  n_cores = NULL,
  desired_iter = 1000,
  status = FALSE,
  ...
)
}
\arguments{
\item{func_for_iter}{A function that takes as
a first argument an integer, the current
iteration. Can take additional arguments
(make sure to export relevant variables).}

\item{to_export}{A character vector, the
variables to export to clusters.}

\item{packages_to_load}{A character vector,
the packages to load on each cluster.}

\item{n_cores}{The number of cores to
use for parallel processing (default is
~75\% of available number of cores).}

\item{desired_iter}{The desired number of
iterations (if not a multiple of \code{n_cores}
will be rounded up internally to the nearest
multiple).}

\item{status}{Logical; if \code{TRUE} indicates
the setup, parallel processing, and conclusion
of the function.}

\item{...}{Additional arguments for the
\code{func_for_iter} function.}
}
\value{
A list of size ~\code{desired_iter} with
the results from each iteration run.
}
\description{
Function to run a user-specified function in
parallel across multiple cores via the
\link[parallel]{parLapply} function. The
function is designed to streamline the steps
for parallel processing on Windows machines.
}
\examples{

func_for_iter <- function( nr ) {
  # Pause system for 1 second
  Sys.sleep(1)
  return(nr)
}

start_time <- Sys.time()
results <- lapply( 1:8, func_for_iter )
run_time <- Sys.time() - start_time
run_time


start_time <- Sys.time()
results <- run_in_parallel(
  func_for_iter, n_cores = 4, desired_iter = 8
)
run_time <- Sys.time() - start_time
run_time

}
